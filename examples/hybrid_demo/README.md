# Hybrid Demo: Python Owner + C/ESP32 Devices

A self-contained example demonstrating SDS communication between:
- **1 Python Owner** - Controls devices and displays their data
- **1 Linux C Device** - Simulated sensor on Linux
- **1 ESP32 Device** - Simulated sensor on ESP32

## Table Schema

```
table DeviceDemo {
    config {
        led_control: uint8       // 0=off, 1=on - controls device LED
        active_device: string    // Node ID of device allowed to publish state
    }
    
    state {
        temperature: float       // Only active_device publishes
        humidity: float          // Only active_device publishes
    }
    
    status {
        power_consumption: float // All devices publish (simulated)
        latest_log: string       // Rotating messages every 5 seconds
    }
}
```

## Behavior

| Component | Behavior |
|-----------|----------|
| **Owner** | Sets `led_control` on/off, sets `active_device` to control which device publishes state |
| **Devices** | Respond to LED control, only `active_device` publishes temperature/humidity |
| **All Devices** | Publish power consumption and rotating log messages to status |

### Data Flows

```
Owner (Python)                    Devices (C/ESP32)
     │                                   │
     │──── config ──────────────────────►│  led_control, active_device
     │                                   │
     │◄─── state (LWW) ─────────────────│  temperature, humidity (active only)
     │                                   │
     │◄─── status (per-device) ─────────│  power_consumption, latest_log
```

## Prerequisites

1. **MQTT Broker** (Mosquitto) running on localhost:1883
   ```bash
   # macOS
   brew install mosquitto
   brew services start mosquitto
   
   # Linux
   sudo apt install mosquitto
   sudo systemctl start mosquitto
   ```

2. **Python 3.8+** with pip

3. **For ESP32**: Arduino IDE or PlatformIO

4. **For Linux device**: GCC and libpaho-mqtt
   ```bash
   # macOS
   brew install libpaho-mqtt
   
   # Linux
   sudo apt install libpaho-mqtt-dev
   ```

## Quick Start

### Step 1: Set Up the Example

```bash
cd examples/hybrid_demo
./generate.sh
```

This script:
1. Copies the SDS library files to `lib/` (making this example self-contained)
2. Generates `lib/include/demo_types.h` (C types) and `python_owner/demo_types.py` (Python types)

### Step 2: Build Linux Device

```bash
cd linux_device
make
```

### Step 2b (Optional): Build ESP32 Device

```bash
cd esp32_device
cp config.h.example config.h
# Edit config.h with your WiFi and MQTT settings
pio run              # Build
pio run -t upload    # Flash to ESP32
pio device monitor   # View serial output
```

### Step 3: Run the Demo

Terminal 1 - Start the Python owner:
```bash
# First time: Install cffi if not already installed
pip install cffi

cd python_owner
python owner.py
```

Terminal 2 - Start Linux device:
```bash
cd linux_device
./device linux_dev_01
```

Terminal 3 (optional) - Start another Linux device or flash ESP32:
```bash
cd linux_device
./device linux_dev_02
```

### Step 4: Interact

In the owner terminal, use commands:
- `led on` / `led off` - Toggle LED on all devices
- `active <node_id>` - Set which device publishes state
- `status` - Show all device statuses
- `verbose on` / `verbose off` - Toggle live state/status messages
- `help` - Show available commands
- `quit` - Exit

## Folder Structure

```
hybrid_demo/
├── README.md              # This file
├── schema.sds             # Table definition
├── generate.sh            # Sets up lib/ and generates types
├── lib/                   # (generated) SDS library copy
│   ├── include/           # Headers + demo_types.h
│   ├── src/               # Source files
│   └── platform/          # Platform implementations
├── linux_device/
│   ├── main.c             # Linux device implementation
│   └── Makefile
├── esp32_device/
│   ├── esp32_device.ino   # ESP32 Arduino sketch
│   └── config.h.example   # WiFi/MQTT configuration template
└── python_owner/
    ├── owner.py           # Python owner implementation
    └── demo_types.py      # (generated) Python types
```

**Note:** `lib/` and `demo_types.py` are generated by `./generate.sh` and not committed to git.

## Educational Notes

This example demonstrates:

1. **Config Broadcast**: Owner publishes config, all devices receive it
2. **Application-Level Access Control**: `active_device` acts as a token
3. **Shared State (LWW)**: Multiple devices could write, but app logic restricts it
4. **Per-Device Status**: Owner tracks each device's health independently
5. **Cross-Language Interop**: Python and C using the same protocol
6. **Callback user_data Pattern**: C callbacks receive table pointer without globals

### C Callback Pattern

The C devices use the `user_data` parameter to access the table in callbacks:

```c
void on_config_update(const char* table_type, void* user_data) {
    DeviceDemoTable* table = (DeviceDemoTable*)user_data;
    
    // Access table data without global variables
    if (table->config.led_control) {
        led_on();
    }
}

int main() {
    DeviceDemoTable table = {0};
    sds_register_table(&table, "DeviceDemo", SDS_ROLE_DEVICE, NULL);
    
    // Pass table pointer as user_data
    sds_on_config_update("DeviceDemo", on_config_update, &table);
}
```
