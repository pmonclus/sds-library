"""
SDS Python Code Generator

Generates Python dataclass definitions from parsed SDS schemas.
"""

from typing import List
from .parser import Schema, Table, Field


class PythonGenerator:
    """Generate Python type definitions from schema."""
    
    def generate(self, schema: Schema) -> str:
        """Generate the Python module content."""
        lines = []
        
        # Header
        lines.append('"""')
        lines.append("sds_types.py - Auto-generated from schema.sds")
        lines.append("")
        lines.append("DO NOT EDIT - This file is generated by sds-codegen")
        lines.append(f"Schema version: {schema.version}")
        lines.append("")
        lines.append("Usage:")
        lines.append("    from sds_types import SensorData")
        lines.append("")
        lines.append('    table = node.register_table("SensorData", Role.DEVICE, schema=SensorData)')
        lines.append("    table.state.temperature = 23.5")
        lines.append('"""')
        lines.append("")
        lines.append("from dataclasses import dataclass")
        lines.append("from sds import Field")
        lines.append("")
        lines.append(f'SCHEMA_VERSION = "{schema.version}"')
        lines.append("")
        
        # Generate each table
        for table_name, table in schema.tables.items():
            lines.extend(self._generate_table(table))
            lines.append("")
        
        # Generate __all__
        table_names = list(schema.tables.keys())
        lines.append("# All exported types")
        lines.append(f"__all__ = {table_names + ['SCHEMA_VERSION']}")
        
        return "\n".join(lines)
    
    def _generate_table(self, table: Table) -> List[str]:
        """Generate code for a single table."""
        lines = []
        name = table.name
        
        lines.append(f"# ============== {name} ==============")
        lines.append("")
        
        # Generate section dataclasses
        if table.config_fields:
            lines.extend(self._generate_section(name, "Config", table.config_fields))
        if table.state_fields:
            lines.extend(self._generate_section(name, "State", table.state_fields))
        if table.status_fields:
            lines.extend(self._generate_section(name, "Status", table.status_fields))
        
        # Generate bundle class
        lines.append("")
        lines.append(f"class {name}:")
        lines.append(f'    """')
        lines.append(f"    Schema bundle for {name} table.")
        lines.append(f"    ")
        lines.append(f"    Usage:")
        lines.append(f'        table = node.register_table("{name}", Role.DEVICE, schema={name})')
        lines.append(f'    """')
        if table.config_fields:
            lines.append(f"    Config = {name}Config")
        if table.state_fields:
            lines.append(f"    State = {name}State")
        if table.status_fields:
            lines.append(f"    Status = {name}Status")
        lines.append(f"    sync_interval_ms = {table.sync_interval_ms}")
        lines.append(f"    liveness_interval_ms = {table.liveness_interval_ms}")
        lines.append("")
        
        return lines
    
    def _generate_section(self, table_name: str, section_name: str, fields: List[Field]) -> List[str]:
        """Generate a section dataclass."""
        lines = []
        
        lines.append("")
        lines.append("@dataclass")
        lines.append(f"class {table_name}{section_name}:")
        lines.append(f'    """{section_name} section of {table_name} table."""')
        
        for f in fields:
            field_args = self._get_field_args(f)
            default = self._get_default(f)
            if field_args:
                lines.append(f"    {f.name}: {self._get_python_type(f)} = Field({field_args}, default={default})")
            else:
                lines.append(f"    {f.name}: {self._get_python_type(f)} = Field(default={default})")
        
        return lines
    
    def _get_python_type(self, f: Field) -> str:
        """Get Python type annotation for a field."""
        if f.type in ("uint8", "uint16", "uint32", "int8", "int16", "int32"):
            return "int"
        elif f.type == "float":
            return "float"
        elif f.type == "bool":
            return "bool"
        elif f.type == "string":
            return "str"
        return "any"
    
    def _get_field_args(self, f: Field) -> str:
        """Get Field() arguments for a field."""
        mapping = {
            "uint8": "uint8=True",
            "uint16": "uint16=True",
            "uint32": "uint32=True",
            "int8": "int8=True",
            "int16": "int16=True",
            "int32": "int32=True",
            "float": "float32=True",
            "bool": "",
            "string": f"string_len={f.array_size or 32}",
        }
        return mapping.get(f.type, "")
    
    def _get_default(self, f: Field) -> str:
        """Get default value for a field."""
        if f.default is not None:
            return str(f.default)
        
        # Provide sensible defaults
        if f.type in ("uint8", "uint16", "uint32", "int8", "int16", "int32"):
            return "0"
        elif f.type == "float":
            return "0.0"
        elif f.type == "bool":
            return "False"
        elif f.type == "string":
            return '""'
        return "None"


def generate_python_file(schema: Schema, output_path: str) -> None:
    """Generate Python file from schema."""
    generator = PythonGenerator()
    content = generator.generate(schema)
    with open(output_path, 'w') as f:
        f.write(content)
