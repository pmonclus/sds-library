"""
SDS C Header Generator

Generates sds_types.h from parsed SDS schema.

For each table, generates:
- {Table}Config struct
- {Table}State struct
- {Table}Status struct
- {Table}Table (for DEVICE role)
- {Table}StatusSlot (for owner's per-device status)
- {Table}OwnerTable (for OWNER role)
- Serialization/deserialization functions
"""

from typing import TextIO, List
from .parser import Schema, Table, Field, SectionType

# Type mapping: SDS type -> C type
TYPE_MAP = {
    'bool': 'uint8_t',
    'uint8': 'uint8_t',
    'int8': 'int8_t',
    'uint16': 'uint16_t',
    'int16': 'int16_t',
    'uint32': 'uint32_t',
    'int32': 'int32_t',
    'float': 'float',
    'string': 'char',
}

# JSON serialization function names
JSON_WRITE_MAP = {
    'bool': 'sds_json_add_bool',
    'uint8': 'sds_json_add_uint',
    'int8': 'sds_json_add_int',
    'uint16': 'sds_json_add_uint',
    'int16': 'sds_json_add_int',
    'uint32': 'sds_json_add_uint',
    'int32': 'sds_json_add_int',
    'float': 'sds_json_add_float',
    'string': 'sds_json_add_string',
}

# JSON deserialization function names
JSON_READ_MAP = {
    'bool': 'sds_json_get_bool_field',
    'uint8': 'sds_json_get_uint8_field',
    'int8': 'sds_json_get_int_field',
    'uint16': 'sds_json_get_uint_field',
    'int16': 'sds_json_get_int_field',
    'uint32': 'sds_json_get_uint_field',
    'int32': 'sds_json_get_int_field',
    'float': 'sds_json_get_float_field',
    'string': 'sds_json_get_string_field',
}

DEFAULT_STRING_SIZE = 32
DEFAULT_MAX_NODES = 16


def _field_to_c(field: Field) -> str:
    """Convert a field to C declaration."""
    c_type = TYPE_MAP.get(field.type, 'uint8_t')
    
    if field.type == 'string':
        size = field.array_size if field.array_size else DEFAULT_STRING_SIZE
        return f"{c_type} {field.name}[{size}]"
    elif field.array_size:
        return f"{c_type} {field.name}[{field.array_size}]"
    else:
        return f"{c_type} {field.name}"


def _to_upper_snake(name: str) -> str:
    """Convert CamelCase to UPPER_SNAKE_CASE."""
    result = []
    for i, c in enumerate(name):
        if c.isupper() and i > 0:
            result.append('_')
        result.append(c.upper())
    return ''.join(result)


def _to_lower_snake(name: str) -> str:
    """Convert CamelCase to lower_snake_case."""
    result = []
    for i, c in enumerate(name):
        if c.isupper() and i > 0:
            result.append('_')
        result.append(c.lower())
    return ''.join(result)


def generate_header(schema: Schema, output: TextIO):
    """Generate C header file from schema."""
    
    # File header
    output.write("/*\n")
    output.write(" * sds_types.h - Auto-generated from schema.sds\n")
    output.write(" * \n")
    output.write(" * DO NOT EDIT - This file is generated by sds-codegen\n")
    output.write(f" * Schema version: {schema.version}\n")
    output.write(" */\n\n")
    
    output.write("#ifndef SDS_TYPES_H\n")
    output.write("#define SDS_TYPES_H\n\n")
    
    output.write(f'#define SDS_SCHEMA_VERSION "{schema.version}"\n\n')
    
    output.write("#include <stdint.h>\n")
    output.write("#include <stdbool.h>\n")
    output.write("#include <stddef.h>\n")
    output.write('#include "sds.h"\n')
    output.write('#include "sds_json.h"\n\n')
    
    # Configuration
    output.write(f"#define SDS_GENERATED_MAX_NODES {DEFAULT_MAX_NODES}\n\n")
    
    # Generate each table
    for name, table in schema.tables.items():
        _generate_table(output, name, table)
    
    # Generate max section size macro (for shadow buffer sizing)
    _generate_max_section_size(output, schema)
    
    # Generate table registry
    _generate_table_registry(output, schema)
    
    output.write("#endif /* SDS_TYPES_H */\n")


def _generate_table(output: TextIO, name: str, table: Table):
    """Generate structures and functions for a table."""
    upper_name = _to_upper_snake(name)
    lower_name = _to_lower_snake(name)
    
    output.write(f"/* ============== Table: {name} ============== */\n\n")
    output.write(f"#define SDS_{upper_name}_SYNC_INTERVAL_MS {table.sync_interval_ms}\n")
    output.write(f"#define SDS_{upper_name}_LIVENESS_INTERVAL_MS {table.liveness_interval_ms}\n\n")
    
    # Config struct
    if table.config_fields:
        output.write(f"/* Config section (Owner → Devices) */\n")
        output.write(f"typedef struct {{\n")
        for field in table.config_fields:
            output.write(f"    {_field_to_c(field)};\n")
        output.write(f"}} {name}Config;\n\n")
    
    # State struct
    if table.state_fields:
        output.write(f"/* State section (All → Owner, LWW) */\n")
        output.write(f"typedef struct {{\n")
        for field in table.state_fields:
            output.write(f"    {_field_to_c(field)};\n")
        output.write(f"}} {name}State;\n\n")
    
    # Status struct
    if table.status_fields:
        output.write(f"/* Status section (Device → Owner) */\n")
        output.write(f"typedef struct {{\n")
        for field in table.status_fields:
            output.write(f"    {_field_to_c(field)};\n")
        output.write(f"}} {name}Status;\n\n")
    
    # Device Table (combined)
    output.write(f"/* Device Table (for SDS_ROLE_DEVICE) */\n")
    output.write(f"typedef struct {{\n")
    if table.config_fields:
        output.write(f"    {name}Config config;\n")
    if table.state_fields:
        output.write(f"    {name}State state;\n")
    if table.status_fields:
        output.write(f"    {name}Status status;\n")
    output.write(f"}} {name}Table;\n\n")
    
    # Status Slot (for owner's per-device tracking)
    if table.status_fields:
        output.write(f"/* Status slot for per-device tracking at Owner */\n")
        output.write(f"typedef struct {{\n")
        output.write(f"    char node_id[SDS_MAX_NODE_ID_LEN];\n")
        output.write(f"    bool valid;\n")
        output.write(f"    bool online;           /* false if LWT received or graceful disconnect */\n")
        output.write(f"    uint32_t last_seen_ms; /* Timestamp of last received status */\n")
        output.write(f"    {name}Status status;\n")
        output.write(f"}} {name}StatusSlot;\n\n")
    
    # Owner Table
    output.write(f"/* Owner Table (for SDS_ROLE_OWNER) */\n")
    output.write(f"typedef struct {{\n")
    if table.config_fields:
        output.write(f"    {name}Config config;\n")
    if table.state_fields:
        output.write(f"    {name}State state;  /* Merged from all devices */\n")
    if table.status_fields:
        output.write(f"    {name}StatusSlot status_slots[SDS_GENERATED_MAX_NODES];\n")
        output.write(f"    uint8_t status_count;\n")
    output.write(f"}} {name}OwnerTable;\n\n")
    
    # Serialization functions
    _generate_serialize_functions(output, name, table)
    
    # Deserialization functions
    _generate_deserialize_functions(output, name, table)


def _generate_serialize_functions(output: TextIO, name: str, table: Table):
    """Generate serialization functions for config/state/status."""
    lower_name = _to_lower_snake(name)
    
    # Config serialize
    if table.config_fields:
        output.write(f"static void {lower_name}_serialize_config(void* section, SdsJsonWriter* w) {{\n")
        output.write(f"    {name}Config* cfg = ({name}Config*)section;\n")
        for field in table.config_fields:
            _write_serialize_field(output, field, 'cfg')
        output.write(f"}}\n\n")
    
    # State serialize
    if table.state_fields:
        output.write(f"static void {lower_name}_serialize_state(void* section, SdsJsonWriter* w) {{\n")
        output.write(f"    {name}State* st = ({name}State*)section;\n")
        for field in table.state_fields:
            _write_serialize_field(output, field, 'st')
        output.write(f"}}\n\n")
    
    # Status serialize
    if table.status_fields:
        output.write(f"static void {lower_name}_serialize_status(void* section, SdsJsonWriter* w) {{\n")
        output.write(f"    {name}Status* st = ({name}Status*)section;\n")
        for field in table.status_fields:
            _write_serialize_field(output, field, 'st')
        output.write(f"}}\n\n")


def _generate_deserialize_functions(output: TextIO, name: str, table: Table):
    """Generate deserialization functions for config/state/status."""
    lower_name = _to_lower_snake(name)
    
    # Config deserialize
    if table.config_fields:
        output.write(f"static void {lower_name}_deserialize_config(void* section, SdsJsonReader* r) {{\n")
        output.write(f"    {name}Config* cfg = ({name}Config*)section;\n")
        for field in table.config_fields:
            _write_deserialize_field(output, field, 'cfg')
        output.write(f"}}\n\n")
    
    # State deserialize
    if table.state_fields:
        output.write(f"static void {lower_name}_deserialize_state(void* section, SdsJsonReader* r) {{\n")
        output.write(f"    {name}State* st = ({name}State*)section;\n")
        for field in table.state_fields:
            _write_deserialize_field(output, field, 'st')
        output.write(f"}}\n\n")
    
    # Status deserialize
    if table.status_fields:
        output.write(f"static void {lower_name}_deserialize_status(void* section, SdsJsonReader* r) {{\n")
        output.write(f"    {name}Status* st = ({name}Status*)section;\n")
        for field in table.status_fields:
            _write_deserialize_field(output, field, 'st')
        output.write(f"}}\n\n")


def _write_serialize_field(output: TextIO, field: Field, ptr_name: str = 'cfg'):
    """Write serialization code for a single field."""
    if field.type == 'string':
        output.write(f'    sds_json_add_string(w, "{field.name}", {ptr_name}->{field.name});\n')
    elif field.type == 'bool':
        output.write(f'    sds_json_add_bool(w, "{field.name}", {ptr_name}->{field.name});\n')
    elif field.type == 'float':
        output.write(f'    sds_json_add_float(w, "{field.name}", {ptr_name}->{field.name});\n')
    elif field.type.startswith('int'):
        output.write(f'    sds_json_add_int(w, "{field.name}", {ptr_name}->{field.name});\n')
    else:
        output.write(f'    sds_json_add_uint(w, "{field.name}", {ptr_name}->{field.name});\n')


def _write_deserialize_field(output: TextIO, field: Field, ptr_name: str):
    """Write deserialization code for a single field."""
    if field.type == 'string':
        size = field.array_size if field.array_size else DEFAULT_STRING_SIZE
        output.write(f'    sds_json_get_string_field(r, "{field.name}", {ptr_name}->{field.name}, {size});\n')
    elif field.type == 'uint8':
        output.write(f'    sds_json_get_uint8_field(r, "{field.name}", &{ptr_name}->{field.name});\n')
    elif field.type == 'bool':
        output.write(f'    {{ bool tmp; if (sds_json_get_bool_field(r, "{field.name}", &tmp)) {ptr_name}->{field.name} = tmp; }}\n')
    elif field.type == 'float':
        output.write(f'    sds_json_get_float_field(r, "{field.name}", &{ptr_name}->{field.name});\n')
    elif field.type in ('int8', 'int16', 'int32'):
        output.write(f'    {{ int32_t tmp; if (sds_json_get_int_field(r, "{field.name}", &tmp)) {ptr_name}->{field.name} = tmp; }}\n')
    elif field.type in ('uint16', 'uint32'):
        output.write(f'    {{ uint32_t tmp; if (sds_json_get_uint_field(r, "{field.name}", &tmp)) {ptr_name}->{field.name} = tmp; }}\n')
    else:
        output.write(f'    sds_json_get_uint_field(r, "{field.name}", &{ptr_name}->{field.name});\n')


def _generate_max_section_size(output: TextIO, schema: Schema):
    """Generate compile-time max section size for shadow buffer sizing."""
    output.write("/* ============== Max Section Size (for shadow buffers) ============== */\n\n")
    output.write("/* Helper macros for compile-time max calculation */\n")
    output.write("#define _SDS_MAX2(a, b) ((a) > (b) ? (a) : (b))\n")
    output.write("#define _SDS_MAX3(a, b, c) _SDS_MAX2(_SDS_MAX2(a, b), c)\n\n")
    
    # Collect all section size expressions
    size_exprs = []
    for name, table in schema.tables.items():
        if table.config_fields:
            size_exprs.append(f"sizeof({name}Config)")
        if table.state_fields:
            size_exprs.append(f"sizeof({name}State)")
        if table.status_fields:
            size_exprs.append(f"sizeof({name}Status)")
    
    if not size_exprs:
        output.write("#define SDS_GENERATED_MAX_SECTION_SIZE 64\n\n")
        return
    
    # Build nested MAX expression
    output.write("/* Auto-calculated maximum section size across all tables */\n")
    output.write("#define SDS_GENERATED_MAX_SECTION_SIZE ( \\\n")
    
    # Process in groups of 3 for _SDS_MAX3
    while len(size_exprs) > 3:
        # Group first 3 into a MAX3
        expr = f"_SDS_MAX3({size_exprs[0]}, {size_exprs[1]}, {size_exprs[2]})"
        size_exprs = [expr] + size_exprs[3:]
    
    if len(size_exprs) == 3:
        output.write(f"    _SDS_MAX3({size_exprs[0]}, {size_exprs[1]}, {size_exprs[2]}) \\\n")
    elif len(size_exprs) == 2:
        output.write(f"    _SDS_MAX2({size_exprs[0]}, {size_exprs[1]}) \\\n")
    else:
        output.write(f"    ({size_exprs[0]}) \\\n")
    
    output.write(")\n\n")


def _generate_table_registry(output: TextIO, schema: Schema):
    """Generate table registry with complete metadata for runtime lookup."""
    output.write("/* ============== Table Registry ============== */\n\n")
    
    output.write(f"#define SDS_TABLE_REGISTRY_COUNT {len(schema.tables)}\n\n")
    
    # Generate the registry array with all metadata
    output.write("static const SdsTableMeta SDS_TABLE_REGISTRY[] = {\n")
    for name, table in schema.tables.items():
        upper_name = _to_upper_snake(name)
        lower_name = _to_lower_snake(name)
        
        output.write(f"    /* {name} */\n")
        output.write("    {\n")
        output.write(f'        .table_type = "{name}",\n')
        output.write(f"        .sync_interval_ms = SDS_{upper_name}_SYNC_INTERVAL_MS,\n")
        output.write(f"        .liveness_interval_ms = SDS_{upper_name}_LIVENESS_INTERVAL_MS,\n")
        output.write(f"        .device_table_size = sizeof({name}Table),\n")
        output.write(f"        .owner_table_size = sizeof({name}OwnerTable),\n")
        
        # Device role offsets
        if table.config_fields:
            output.write(f"        .dev_config_offset = offsetof({name}Table, config),\n")
            output.write(f"        .dev_config_size = sizeof({name}Config),\n")
        else:
            output.write("        .dev_config_offset = 0,\n")
            output.write("        .dev_config_size = 0,\n")
        
        if table.state_fields:
            output.write(f"        .dev_state_offset = offsetof({name}Table, state),\n")
            output.write(f"        .dev_state_size = sizeof({name}State),\n")
        else:
            output.write("        .dev_state_offset = 0,\n")
            output.write("        .dev_state_size = 0,\n")
        
        if table.status_fields:
            output.write(f"        .dev_status_offset = offsetof({name}Table, status),\n")
            output.write(f"        .dev_status_size = sizeof({name}Status),\n")
        else:
            output.write("        .dev_status_offset = 0,\n")
            output.write("        .dev_status_size = 0,\n")
        
        # Owner role offsets
        if table.config_fields:
            output.write(f"        .own_config_offset = offsetof({name}OwnerTable, config),\n")
            output.write(f"        .own_config_size = sizeof({name}Config),\n")
        else:
            output.write("        .own_config_offset = 0,\n")
            output.write("        .own_config_size = 0,\n")
        
        if table.state_fields:
            output.write(f"        .own_state_offset = offsetof({name}OwnerTable, state),\n")
            output.write(f"        .own_state_size = sizeof({name}State),\n")
        else:
            output.write("        .own_state_offset = 0,\n")
            output.write("        .own_state_size = 0,\n")
        
        # Owner status slot metadata (for per-device tracking)
        if table.status_fields:
            output.write(f"        .own_status_slots_offset = offsetof({name}OwnerTable, status_slots),\n")
            output.write(f"        .own_status_slot_size = sizeof({name}StatusSlot),\n")
            output.write(f"        .own_status_count_offset = offsetof({name}OwnerTable, status_count),\n")
            output.write(f"        .slot_status_offset = offsetof({name}StatusSlot, status),\n")
            output.write("        .own_max_status_slots = SDS_GENERATED_MAX_NODES,\n")
        else:
            output.write("        .own_status_slots_offset = 0,\n")
            output.write("        .own_status_slot_size = 0,\n")
            output.write("        .own_status_count_offset = 0,\n")
            output.write("        .slot_status_offset = 0,\n")
            output.write("        .own_max_status_slots = 0,\n")
        
        # Serialization callbacks
        if table.config_fields:
            output.write(f"        .serialize_config = {lower_name}_serialize_config,\n")
        else:
            output.write("        .serialize_config = NULL,\n")
        
        if table.state_fields:
            output.write(f"        .serialize_state = {lower_name}_serialize_state,\n")
        else:
            output.write("        .serialize_state = NULL,\n")
        
        if table.status_fields:
            output.write(f"        .serialize_status = {lower_name}_serialize_status,\n")
        else:
            output.write("        .serialize_status = NULL,\n")
        
        # Deserialization callbacks
        if table.config_fields:
            output.write(f"        .deserialize_config = {lower_name}_deserialize_config,\n")
        else:
            output.write("        .deserialize_config = NULL,\n")
        
        if table.state_fields:
            output.write(f"        .deserialize_state = {lower_name}_deserialize_state,\n")
        else:
            output.write("        .deserialize_state = NULL,\n")
        
        if table.status_fields:
            output.write(f"        .deserialize_status = {lower_name}_deserialize_status,\n")
        else:
            output.write("        .deserialize_status = NULL,\n")
        
        output.write("    },\n")
    
    output.write("};\n\n")
    
    # Add auto-registration using constructor attribute
    # This runs automatically before main() on GCC/Clang (POSIX and ESP32)
    output.write("/* Auto-register tables with SDS core (runs before main) */\n")
    output.write("#if defined(__GNUC__) || defined(__clang__)\n")
    output.write("__attribute__((constructor))\n")
    output.write("#endif\n")
    output.write("static void _sds_auto_register_types(void) {\n")
    output.write("    sds_set_table_registry(SDS_TABLE_REGISTRY, SDS_TABLE_REGISTRY_COUNT);\n")
    output.write("}\n\n")


def generate_header_file(schema: Schema, path: str):
    """Generate C header file to disk."""
    with open(path, 'w') as f:
        generate_header(schema, f)

